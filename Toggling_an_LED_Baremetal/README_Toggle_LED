Code Breakdown and Line-by-Line Explanation

Header Inclusion

#include "stm32f4xx.h"

Purpose: Includes the STM32F4xx Device Header, which defines register addresses, bit masks, and peripheral structures for the STM32F4xx series (e.g., STM32F446RE).
Details: Provided by STMicroelectronics (part of the CMSIS or STM32CubeF4 package), this header maps registers like RCC->AHB1ENR and GPIOA->MODER to memory addresses (e.g., RCC base at 0x40023800, GPIOA at 0x40020000). It enables direct hardware access without needing to define memory-mapped addresses manually.
Principle: Embedded C uses such headers to ensure portability across STM32F4xx variants, abstracting specific register layouts while allowing bare-metal programming.

Function Declaration

void delayMs(int n);

Purpose: Declares a function delayMs that creates a delay in milliseconds, taking an integer parameter n for the delay duration.
Details: Forward declaration ensures the compiler knows about delayMs before its use in main. The function is defined later to implement a software-based delay.
Principle: In embedded systems, delays are critical for timing tasks (e.g., LED blinking). Without an RTOS, software loops are common for simple delays, though they are CPU-intensive and less precise than hardware timers.

Main Function

int main(void) {

Purpose: Entry point of the program, where execution begins after reset.
Details: In embedded systems, main runs in an infinite loop (no return to OS), as the microcontroller operates continuously. The return type int is conventional but unused, as there’s no caller to return to.
Principle: The STM32 starts execution from the Reset Handler (defined in the startup code, e.g., startup_stm32f446xx.s), which initializes the stack, data sections, and calls main.

Enable GPIOA Clock

RCC->AHB1ENR |= 1; /* enable GPIOA clock */

Purpose: Enables the clock for GPIOA peripheral to make it operational.
Details:

RCC is a pointer to the Reset and Clock Control registers (base address 0x40023800).
AHB1ENR (AHB1 Enable Register, offset 0x30) controls clock gating for AHB1 peripherals.
|= 1 sets bit 0 (GPIOAEN), enabling the clock for GPIOA (1 << 0 = 0x00000001).
From RM0090, GPIOA is on the AHB1 bus, and enabling its clock is mandatory before configuring GPIO pins to avoid undefined behavior.


Principle: Clock gating saves power in STM32 by disabling unused peripherals. The |= operator performs a read-modify-write to preserve other bits.

Clear GPIOA Pin 5 Mode

GPIOA->MODER &= ~0x00000C00; /* clear pin mode */

Purpose: Clears the mode bits for GPIOA pin 5 (PA5) to prepare for configuration.
Details:

GPIOA points to GPIOA registers (base address 0x40020000).
MODER (Mode Register, offset 0x00) sets the mode for each pin (2 bits per pin: 00 = input, 01 = output, 10 = alternate function, 11 = analog).
For PA5, bits 10 and 11 in MODER control the mode (MODER[11:10]).
0x00000C00 = binary 1100 0000 0000 (bits 11:10 set).
~0x00000C00 = 1111 1111 0011 1111 1111 inverts to clear bits 11:10.
&= ~0x00000C00 clears bits 11:10 to 00 (input mode temporarily), preserving other pins’ settings.


Principle: Clearing bits before setting ensures a clean state, avoiding unintended configurations. This is a standard practice in register programming to prevent glitches.

Set GPIOA Pin 5 to Output Mode

GPIOA->MODER |= 0x00000400; /* set pin to output mode */

Purpose: Configures PA5 as a general-purpose output pin.
Details:

0x00000400 = binary 0100 0000 0000 (bit 10 = 1, bit 11 = 0).
Sets MODER[11:10] = 01 for PA5, configuring it as output.
|= performs a read-modify-write, setting bit 10 while keeping other bits unchanged.
On Nucleo-F446RE, PA5 is connected to the green LED (LD2), making it suitable for output.


Principle: GPIO mode configuration defines pin behavior. Output mode allows the MCU to drive the pin high/low, controlling external devices like LEDs.

Infinite Loop

while(1) {

Purpose: Creates an infinite loop to keep the program running continuously.
Details: Embedded systems typically run forever, as there’s no OS to exit to. This loop contains the LED blinking logic.
Principle: The infinite loop ensures the microcontroller repeatedly executes the application code, typical for embedded firmware.

Turn On LED

GPIOA->ODR |= 0x00000020; /* turn on LED */

Purpose: Sets PA5 high to turn on the LED.
Details:

ODR (Output Data Register, offset 0x14) controls the output state of GPIOA pins.
0x00000020 = binary 0010 0000 (bit 5 = 1, corresponds to PA5).
|= sets bit 5 to 1, driving PA5 high (3.3V), which lights the LED on Nucleo (active-high).


Principle: Writing to ODR directly controls pin voltage. For LEDs, high typically turns it on, depending on the board’s wiring (Nucleo’s LD2 is active-high).

Delay for LED On
cdelayMs(500);

Purpose: Introduces a 500ms delay while the LED is on.
Details: Calls the delayMs function with n = 500, pausing execution for approximately 500ms to make the LED visibly on.
Principle: Timing is critical in embedded systems for observable effects. Software delays are simple but block the CPU, unlike timer-based delays.

Turn Off LED

GPIOA->ODR &= ~0x00000020; /* turn off LED */

Purpose: Clears PA5 to turn off the LED.
Details:

0x00000020 targets bit 5 (PA5).
~0x00000020 = 1111 1111 1101 1111 inverts to clear bit 5.
&= ~0x00000020 clears bit 5 to 0, driving PA5 low (0V), turning off the LED.


Principle: Clearing ODR bits sets pins low. This is a read-modify-write operation to avoid affecting other pins.

Delay for LED Off

delayMs(500);

Purpose: Introduces a 500ms delay while the LED is off.
Details: Calls delayMs(500) again, creating a symmetric on/off cycle for blinking.
Principle: Consistent delays ensure a 1-second period (500ms on + 500ms off), making the blinking visible to the human eye (typical LED blink rate is 1-2 Hz).

Closing Main
}

Purpose: Closes the infinite while loop and main function.
Details: Ensures the LED blinks indefinitely.
Principle: Embedded programs typically never exit main, running tasks in a loop.

Delay Function Definition

/* 16 MHz SYSCLK */
void delayMs(int n) {

Purpose: Defines the delayMs function to create an n-millisecond delay.
Details: The comment indicates the system clock is 16 MHz (HSI oscillator, default for STM32F4xx without PLL). This informs the delay loop’s calibration.
Principle: Software delays rely on CPU cycles, calibrated to the system clock. For 16 MHz, one instruction cycle is approximately 62.5 ns.

Delay Loop Variables

int i;

Purpose: Declares a loop counter i for the inner delay loop.
Details: Used as a local variable within delayMs to count iterations for timing.
Principle: Local variables minimize stack usage in embedded systems, critical for MCUs with limited RAM (e.g., 128 KB on STM32F446RE).

Outer Delay Loop

for (; n > 0; n--)

Purpose: Loops n times, where each iteration approximates 1ms.
Details: The outer loop decrements n from the input value (e.g., 500) to 0, executing the inner loop for each millisecond.
Principle: Nested loops scale delays by repeating a fixed cycle count, allowing millisecond precision.

Inner Delay Loop

for (i = 0; i < 3195; i++) ;

Purpose: Executes 3195 iterations to approximate a 1ms delay at 16 MHz.
Details:

The inner loop is empty (;), performing no work except incrementing i and checking the condition.
At 16 MHz, each cycle is 62.5 ns. A simple for loop iteration (increment, compare, branch) takes approximately 3-4 cycles in ARM Cortex-M4 (Thumb-2 instructions).
Assuming 4 cycles per iteration: 3195 iterations × 4 cycles × 62.5 ns = ~799,875 ns ≈ 0.8ms.
The value 3195 was empirically determined (as noted in the book) to account for loop overhead and compiler optimizations, approximating 1ms per outer loop iteration.


Principle: Software delays are calibrated by counting CPU cycles. The exact number (3195) depends on compiler (e.g., Keil uVision, arm-none-eabi-gcc) and optimization level (e.g., -O0). This is less precise than hardware timers but simpler for basic tasks.

Closing Delay Function

}

Purpose: Closes the delayMs function.
Details: Completes the function, returning control to main after the delay.
Principle: Structured programming ensures clear function boundaries, critical for maintainability in embedded code.
