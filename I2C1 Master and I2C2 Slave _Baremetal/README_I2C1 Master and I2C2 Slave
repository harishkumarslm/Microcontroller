Below is a step-by-step explanation for a `README.md` file for the provided I2C1 (master) to I2C2 (slave) communication code on the STM32F446RE microcontroller. The `README` is designed to be detailed and accessible, suitable for developers or students learning bare-metal I2C communication. It includes an overview, hardware/software requirements, setup instructions, code functionality, troubleshooting, and customization options, tailored to the code's purpose of demonstrating inter-I2C data transfer with incrementing responses.

---

# README.md

## I2C1 Master to I2C2 Slave Communication Example for STM32F446RE

### Overview
This project implements a bare-metal I2C (Inter-Integrated Circuit) communication example on the STM32F446RE microcontroller (e.g., Nucleo-F446RE board), where I2C1 acts as the master and I2C2 as the slave. The master sends a byte starting from 0xAA to the slave address 0x50, and the slave responds with a byte that can be incremented based on prior data. The communication operates at 100 kHz using open-drain pins with external pull-ups, serving as an educational tool for understanding I2C protocols in embedded systems.

### Hardware Requirements
- **Microcontroller**: STM32F446RE (e.g., Nucleo-F446RE development board).
- **Connections**:
  - I2C1 Master (PB6: SCL, PB9: SDA) to I2C2 Slave (PB10: SCL, PB11: SDA).
  - Connect PB6 to PB10 (SCL) and PB9 to PB11 (SDA) using jumper wires.
  - Add external 4.7 kΩ pull-up resistors to 3.3V on both SCL and SDA lines (required for I2C).
- **Tools**:
  - IDE: Keil uVision (v5.24a or later) or equivalent ARM compiler.
  - CMSIS: Include `stm32f4xx.h` header for register definitions.
  - Debug Tools: ST-Link debugger for flashing, optional logic analyzer or oscilloscope for signal verification.

### Software Requirements
- ARM GCC compiler or Keil uVision with STM32F4 support.
- STM32CubeMX (optional) for initial project setup, though not used here.
- Serial terminal or logic analyzer (optional) for monitoring I2C data if routed to UART or GPIO pins.

### Step-by-Step Explanation

#### 1. **Code Structure**
- **Main Function (`main`)**:
  - Enables clocks for GPIOB, I2C1, and I2C2 via `RCC` registers.
  - Configures I2C1 as master (PB6, PB9) and I2C2 as slave (PB10, PB11) with alternate function 4 (AF4).
  - Initializes `master_tx` with 0xAA and enters an infinite loop, calling `i2c1_master_write` to send data, `i2c2_slave_read_write` to process, and `i2c1_master_read` to receive the response.
  - Includes a delay loop (`1000000` iterations) to pace transmissions.
- **Master Write Function (`i2c1_master_write`)**:
  - Generates a start condition (`CR1 bit 8`).
  - Waits for start bit set (`SB`, bit 0 of `SR1`).
  - Sends the 7-bit address (shifted left, write mode) via `DR` and waits for address sent (`ADDR`, bit 1 of `SR1`).
  - Clears `ADDR` by reading `SR2`.
  - Sends data and waits for transmit buffer empty (`TXE`, bit 7 of `SR1`).
  - Generates a stop condition (`CR1 bit 9`).
- **Master Read Function (`i2c1_master_read`)**:
  - Generates a start condition.
  - Waits for `SB`, sends the address with read bit (shifted left | 1), and waits for `ADDR`.
  - Clears `ADDR` by reading `SR2`.
  - Waits for data received (`RXNE`, bit 6 of `SR1`), reads `DR`, and generates a stop condition.
  - Returns the received data.
- **Slave Function (`i2c2_slave_read_write`)**:
  - Waits for address match (`ADDR`, bit 1 of `SR1`).
  - Clears `ADDR` by reading `SR2`.
  - Waits for `RXNE`, reads the received data into `rx_data`.
  - Waits for another `ADDR` (read phase), clears `SR2`, and sends `tx_data` via `DR`.
  - Waits for `TXE` and returns `rx_data`.
- **Operation**: The master writes 0xAA to address 0x50, the slave receives it, and in the read phase, sends back a value (incremented based on `slave_rx + 1`). The master reads this, and `master_tx` increments for the next cycle.

#### 2. **Setup Instructions**
- **Project Configuration**:
  1. Create a new project in Keil uVision targeting STM32F446RE.
  2. Add the `stm32f4xx.h` header from the STM32CubeF4 package.
  3. Copy the provided code into a `.c` file (e.g., `main.c`).
  4. Include the startup file (`startup_stm32f446xx.s`) for vector table setup.
- **Build and Flash**:
  1. Compile the project (resolve any errors, e.g., missing headers).
  2. Connect the ST-Link debugger to the Nucleo board.
  3. Flash the binary to the microcontroller via Keil’s debug interface.
- **Hardware Setup**:
  1. Wire PB6 to PB10 (SCL) and PB9 to PB11 (SDA).
  2. Add 4.7 kΩ pull-up resistors from SCL and SDA to 3.3V.
  3. Power the board and ensure no short circuits.
- **Verification**:
  1. Use a logic analyzer or oscilloscope to monitor SCL (PB6/PB10) and SDA (PB9/PB11) to confirm I2C transactions.
  2. Optionally, route `master_rx` or `slave_rx` to a GPIO or UART pin for debugging output.

#### 3. **Expected Behavior**
- The master sends 0xAA to address 0x50.
- The slave receives it, and in the read phase, sends back `slave_rx + 1` (initially undefined, then increments).
- The master reads the response, and the process repeats with `master_tx` increasing (e.g., 0xAA → 0xAB → 0xAC...).
- The delay loop (~1 second) spaces out transmissions, observable as periodic I2C activity.

#### 4. **Troubleshooting**
- **No Communication**:
  - Verify all pin connections (PB6→PB10, PB9→PB11) and pull-up resistors.
  - Ensure I2C clocks are enabled (`RCC->APB1ENR` bits 21 and 22).
  - Check `I2C2->OAR1` address (0x50) matches the master’s address.
- **Incorrect Data**:
  - Confirm 100 kHz setting (`I2C1->CCR = 80`) aligns with 16 MHz APB1 clock.
  - Verify `I2C1->TRISE = 17` suits the rise time with pull-ups.
- **Program Hangs**:
  - Debug with a breakpoint in `i2c1_master_write` or `i2c2_slave_read_write` to check `SB`, `ADDR`, `RXNE`, or `TXE` flags.
  - Ensure no bus contention (e.g., miswired SDA/SCL).

#### 5. **Customization**
- **Change Address**: Modify `I2C2->OAR1` and `i2c1_master_write/read` address (e.g., 0x51).
- **Adjust Speed**: Update `I2C1->CCR` (e.g., 40 for 200 kHz) and test with a logic analyzer.
- **Precise Timing**: Replace the delay loop with a timer (e.g., TIM2) for accurate intervals.
- **Debug Output**: Add UART (e.g., UART4 on PA0) to print `master_rx` or `slave_rx` values.

#### 6. **Limitations**
- The delay is approximate and CPU-dependent, not suitable for real-time applications.
- No interrupt-based communication; uses polling, which may block the system.
- Requires external pull-ups; internal pull-ups are insufficient for reliable I2C.

### Author
- Harish Kumar A  
- Email: harishkumarslm@gmail.com  
- GitHub: github.com/harishkumarslm  

### License
This code is provided for educational purposes under the MIT License. Modify and distribute freely, but retain the original copyright notice.

### Acknowledgements
- Based on STM32F4 Reference Manual (RM0090).
- Inspired by bare-metal programming examples from *STM32 Arm Programming for Embedded Systems* by Mazidi et al.

---

### Step-by-Step Explanation for README Content

1. **Overview**:
   - Describes the project’s goal (I2C1 master to I2C2 slave communication) and educational focus.
   - Highlights the data increment feature and pull-up requirement.

2. **Hardware Requirements**:
   - Specifies the STM32F446RE and required pin connections with pull-ups.
   - Lists tools (Keil, ST-Link, oscilloscope) for setup and verification.

3. **Software Requirements**:
   - Details the development environment (ARM GCC, Keil) and optional tools.
   - Prepares users for the bare-metal approach.

4. **Step-by-Step Explanation**:
   - Breaks down `main`, `i2c1_master_write`, `i2c1_master_read`, and `i2c2_slave_read_write` functions.
   - Explains register usage (e.g., `RCC->AHB1ENR`, `I2C1->SR1`) and the I2C transaction flow.
   - Clarifies the master-slave interaction (write, read, increment).

5. **Setup Instructions**:
   - Guides users through project creation, compilation, flashing, and hardware wiring.
   - Includes verification steps with a logic analyzer for hands-on learning.

6. **Expected Behavior**:
   - Details the data flow (0xAA → incremented response, etc.) and timing (~1s delay).
   - Helps users confirm correct operation.

7. **Troubleshooting**:
   - Addresses common issues (no communication, incorrect data, hangs) with solutions.
   - Encourages debugging with breakpoints or hardware checks.

8. **Customization**:
   - Suggests modifications (address, speed, timing) to extend functionality.
   - Promotes experimentation with I2C parameters.

9. **Limitations**:
   - Notes the approximate delay, polling nature, and pull-up dependency for transparency.
   - Sets realistic expectations for the code’s scope.

10. **Author and License**:
    - Credits you (Harish Kumar A) with contact details.
    - Applies a permissive MIT License for educational use.

11. **Acknowledgements**:
    - References RM0090 and the Mazidi book, aligning with your prior STM32 work.

This `README.md` provides a complete guide for setting up, understanding, and extending the I2C communication code, serving as both documentation and a learning resource. If you need additional sections (e.g., version history) or specific debugging tips, let me know!
